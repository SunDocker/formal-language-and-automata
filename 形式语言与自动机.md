# 形式语言与自动机

---

---

---

## 概述

---

---

### 一、学科来源

---

#### (一) 计算机的基本能力和限制

- 哪些问题可以通过计算解决——**可计算理论**
- 解决可计算的问题，究竟需要多少资源——**计算复杂性理论**
- 为了研究计算，要使用哪些计算模型——形式语言与自动机理论

#### (二) 自动机理论

- 研究抽象机器及其所能解决问题的理论
- 常见自动机
  - 图灵机
  - 有限状态机
  - 文法，下推自动机

#### (三) 形式语言

- 经数学定义的语言

> 自动机以形式语言为处理对象、语言以自动机为形式而定义

#### (四) 课程结构

- 正则语言
  - 有穷自动机
  - 正则表达式
  - 正则语言的性质
- 上下文无关语言
  - 上下文无关文法
  - 下推自动机
  - 上下文无关语言的性质
- 计算导论
  - 图灵机及其扩展
  - 不可判定性

---

### 二、基本概念

---

#### (一) 字母表

- **符号**(字符)的<u>非空有穷</u>集

#### (二) 字符串和空串

- 字符串：由某**字母表**中符号组成的**有穷**序列

- 特殊的字串——空串：记为$\epsilon$，有**0**个字符的串

  > 字母表$\Sigma$可以是任意的，但都有<u>$\epsilon\notin\Epsilon$</u>

> <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220225092645819.png" alt="image-20220225092645819" style="zoom:67%;" />

#### (三) 字符串相关运算

- *字符串的**长度***：字符串中符号所占位置个数，记为$|字符串|$

  > <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220225092932307.png" alt="image-20220225092932307" style="zoom:67%;" />

- *字符串的**连接***：将**首尾相接**得到新字符串的运算，记为$x·y$或$xy$

  > <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220225093118503.png" alt="image-20220225093118503" style="zoom:67%;" />

  > 连接运算的单位元是**空串**；
  >
  > 满足**结合律**，但不满足**交换律**

- *字符串的幂*

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220225093408534.png" alt="image-20220225093408534" style="zoom:67%;" />

#### (四) 集合相关运算

- *集合的连接*

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220225093518798.png" alt="image-20220225093518798" style="zoom:67%;" />

  > 就是两个集合中的**字符串连接**，是有前后顺序的

- *集合的幂*

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220225093628548.png" alt="image-20220225093628548" style="zoom:67%;" />

> 注意区分**集合**与**字母表**，一般来说，只有字母表中的元素叫做“**字符**/符号”，集合中的叫做**字符串**

- *克林闭包*、*正闭包*

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220225094403235.png" alt="image-20220225094403235" style="zoom:67%;" />

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220225094434100.png" alt="image-20220225094434100" style="zoom:67%;" />

  > 显然：
  >
  > <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220225094458372.png" alt="image-20220225094458372" style="zoom:67%;" />

  > 注：一般来说，==字母表中不包含空串==

---

### 三、语言与问题

---

#### (一) 语言

- 定义：

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220225103408161.png" alt="image-20220225103408161" style="zoom:67%;" />

  > ==字母表**克林闭包**的子集==

  > <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220225103620308.png" alt="image-20220225103620308" style="zoom:67%;" />
  >
  > 唯一重要的约束就是所有字母表都是**有穷**的；
  >
  > 空语言即空集，不包括空字符串

#### (二) 问题

<img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220225103848444.png" alt="image-20220225103848444" style="zoom:67%;" />

> 任何所谓问题，都可以转为**语言成员性**的问题；
>
> 语言和问题其实是相同的东西

#### (三) 形式化证明

- 对**长度**进行归纳

<img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220225104207754.png" alt="image-20220225104207754" style="zoom:67%;" />

- 对**结构**进行归纳

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220225104459342.png" alt="image-20220225104459342" style="zoom:67%;" />

---

---

## 有穷自动机

---

---

### 一、确定的有穷自动机

---

#### (一) 形式定义

- **有穷自动机**也称为**有限状态机**，是**有穷状态系统**的抽象模型

- 有限状态机分类

  - Moore Machine
  - Mealy Machine

- 结构示例

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220225105113316.png" alt="image-20220225105113316" style="zoom:67%;" />

- :star:==确定的有穷自动机的形式定义==

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220225110252614.png" alt="image-20220225110252614" style="zoom:67%;" />

#### (二) DFA的设计举例

- **图**的方式表示DFA

  - 每个<u>状态q</u>对应一个**节点**，用圆圈表示;
  - 状态<u>转移δ(q,a)=p</u>为一条从q到p且标记为字符a的**有向边**;
  - <u>开始状态q0</u>用一个标有**start**的箭头表示;
  - <u>接受状态</u>的节点，用**双圆圈**表示

- 状态转移表

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220225112044215.png" alt="image-20220225112044215" style="zoom:67%;" />

- 典型问题：设计DFA使其**接受且仅接受**给定的**语言L**

> 举例：两个有穷状态自动机的**笛卡尔积**，让两个自动机一起跑
>
> <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220225112541979.png" alt="image-20220225112541979" style="zoom:67%;" />
>
> 给状态编号，然后分类讨论

#### (三) 扩展转换函数与DFA的语言

- :star:**扩展转移函数**

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220225112844015.png" alt="image-20220225112844015" style="zoom:67%;" />

> 扩展转换函数**处理**过程举例：
>
> <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220225113018434.png" alt="image-20220225113018434" style="zoom:67%;" />

> 扩展转换函数证明题举例：对**结构**归纳
>
> <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220225113622322.png" alt="image-20220225113622322" style="zoom:67%;" />

- :star:**DFA的语言**和**正则语言**

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220225113816903.png" alt="image-20220225113816903" style="zoom:67%;" />

> 题目举例：
>
> <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220225115001087.png" alt="image-20220225115001087" style="zoom:67%;" />
>
> 读的过程就是**右移**的过程，就是**乘二**或者**乘二加一**

---

### 二、非确定有穷自动机

---

> 理解状态转移的非确定性：
>
> <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220225115742335.png" alt="image-20220225115742335" style="zoom:67%;" />
>
> - 同一个状态在相同的输入下，可以有**多个转移状态**
> - 自动机可以处在**多个当前状态**
> - 使自动机的设计更容易
>
> 确定与非确定的举例：
>
> <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220225120100163.png" alt="image-20220225120100163" style="zoom:67%;" />

#### (一) 形式语言

- :star:==非确定有穷自动机的形式定义==

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220225120527627.png" alt="image-20220225120527627" style="zoom:67%;" />

  > 状态转移的过程相当于一棵**树**

> NFA五元组举例分析：
>
> <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220225121111582.png" alt="image-20220225121111582" style="zoom:67%;" />
>
> 如果(所有)下一个状态集合(的**并集**)是空集，状态机就会卡住
>
> <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220225121442147.png" alt="image-20220225121442147" style="zoom:67%;" />
>
> 只要最后的状态集合**包含可接收的状态**，就认为可接收字符串
>
> NFA的状态转移表如下：
>
> <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220225121629481.png" alt="image-20220225121629481" style="zoom:67%;" />

#### (二) 扩展转移函数与NFA语言

- NFA 的扩展转移函数

<img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220301083342074.png" alt="image-20220301083342074" style="zoom:67%;" />

> 建议与 DFA 的对比

- NFA 的语言

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220301083630517.png" alt="image-20220301083630517" style="zoom:67%;" />

> NFA 设计举例：
>
> $\Rarr$有误的例子
>
> <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220301084205809.png" alt="image-20220301084205809" style="zoom:67%;" />
>
> > 注意，这个设计有误，不能接收单字符
>
> $\Rarr$两类可接收状态的 **NFA 拼接**与==分类讨论==
>
> ![image-20220301084926342](C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220301084926342.png)

#### (三) DFA与NFA的等价性

- :star:定理1：如果语言L被NFA接受，当且仅当L被DFA接受

  > 也就是说，==NFA 并没有增加识别语言的能力==；
  >
  > 但如果稍做改动，DFA 识别语言的能力和效率就有可能发生改变

  > :star:证明：==**子集构造法**==
  >
  > <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220301085809176.png" alt="image-20220301085809176" style="zoom:67%;" />
  >
  > > NFA 能接收多个状态，
  > >
  > > DFA 就直接**包装成一个集合**，整体再当作**一个状态**
  >
  > <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220301090215571.png" alt="image-20220301090215571" style="zoom:67%;" />
  >
  > <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220301090358501.png" alt="image-20220301090358501" style="zoom:67%;" />
  >
  > > NFA 与 DFA 识别的语言相同

- 思考：非确定性没能增加有穷自动机的能力,原因是什么呢?

  > NFA 不过就是有<u>$2^n$种可能的情况</u>，也是有穷的

> 子集构造法举例：
>
> 借助 NFA 的状态表，
>
> DFA 从$\{q_0\}$开始，每个$\{q_x,q_y,...\}$集合算作一个状态，
>
> 当不再有新状态时，标出接收状态
>
> <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220301094752580.png" alt="image-20220301094752580" style="zoom:67%;" />

---

### 三、带有空转换的非确定有穷自动机

---

#### (一) 形式定义

- 状态的$\epsilon$转移

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220301095424240.png" alt="image-20220301095424240" style="zoom50%;" />

  > 空转移设计举例：
  >
  > <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220301095506678.png" alt="image-20220301095506678" style="zoom:67%;" />

- :star:**==形式定义==**

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220301100337301.png" alt="image-20220301100337301" style="zoom:67%;" />

  > $\epsilon-NFA,NFA,DFA$对比：
  >
  > <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220301100559004.png" alt="image-20220301100559004" style="zoom:67%;" />
  >
  > <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220301100613198.png" alt="image-20220301100613198" style="zoom:67%;" />

> 举例：
>
> <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220301100732790.png" alt="image-20220301100732790" style="zoom:67%;" />
>
> 所以之后写 NFA 的时候，如果空转移不都为死状态，应该写上这一列

#### (二) $\epsilon$闭包

> NFA 读入分析：
>
> <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220301101056219.png" alt="image-20220301101056219" style="zoom:67%;" />
>
> 空转移要写全

- :star:状态的$\epsilon$闭包

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220301101356351.png" alt="image-20220301101356351" style="zoom:67%;" />

- :star:状态集的$\epsilon$闭包

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220301101449757.png" alt="image-20220301101449757" style="zoom:67%;" />

> 举例：
>
> <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220301101654250.png" alt="image-20220301101654250" style="zoom:67%;" />
>
> 状态集的空闭包更实用一些，一次把可能的状态都写出来了

#### (三) 扩展转移函数与$\epsilon-NFA$的语言

- :star:扩展转移函数

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304103834452.png" alt="image-20220304103834452" style="zoom:67%;" />

  > 举例：
  >
  > <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304103937159.png" alt="image-20220304103937159" style="zoom:67%;" />
  >
  > > 其实就是多了一步==求闭包==

- :star:$\epsilon-NFA$的语言

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304104008638.png" alt="image-20220304104008638" style="zoom:67%;" />

#### (四) $\epsilon-NFA$与$DFA$等价性

- 证明：子集构造法（消除空转移）

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304104403019.png" alt="image-20220304104403019" style="zoom:50%;" />

  > 举例理解这个构造：
  >
  > <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304104803203.png" alt="image-20220304104803203" style="zoom:50%;" />

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304105314873.png" alt="image-20220304105314873" style="zoom:50%;" />

  > 反过来是显然的，因为可以不要空转移，之前证明过了

> $\epsilon-DFA$设计举例：
>
> 多接收状态拼装法
>
> <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304105528328.png" alt="image-20220304105528328" style="zoom:50%;" />
>
> <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304105539324.png" alt="image-20220304105539324" style="zoom:50%;" />

---

---

## 正则表达式

---

---

### 一、正则表达式

---

> 正则表达式与有穷自动机具有等价性

> 特殊集合的运算：
>
> <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304110542493.png" alt="image-20220304110542493" style="zoom:50%;" />

#### (一) 正则表达式的递归定义

- 四则运算表达式的递归定义

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304110649833.png" alt="image-20220304110649833" style="zoom:50%;" />

- :star:正则表达式的递归定义

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304110940465.png" alt="image-20220304110940465" style="zoom:67%;" />

  > 举例理解：
  >
  > <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304111037573.png" alt="image-20220304111037573" style="zoom:67%;" />

- 运算符的优先级：

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304111110462.png" alt="image-20220304111110462" style="zoom:50%;" />

  > 举例：
  >
  > <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304111330519.png" alt="image-20220304111330519" style="zoom:50%;" />

#### (二) 正则表达式示例

- <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304111627646.png" alt="image-20220304111627646" style="zoom:50%;" />

- <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304111730973.png" alt="image-20220304111730973" style="zoom:50%;" />

- <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304111830006.png" alt="image-20220304111830006" style="zoom:50%;" />

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304111853063.png" alt="image-20220304111853063" style="zoom:50%;" />

- 删减改造法，注意检查特殊情况

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304112245939.png" alt="image-20220304112245939" style="zoom:50%;" />

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304112328514.png" alt="image-20220304112328514" style="zoom:50%;" />

  > 或者：
  >
  > 用于产生连续的 0 和 1 + 用于接收连续的 0 和 1：
  >
  > <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304112608917.png" alt="image-20220304112608917" style="zoom:50%;" />
  >
  > <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304112908298.png" alt="image-20220304112908298" style="zoom:50%;" />

---

### 二、自动机和正则表达式

---

> 证明思路：
>
> <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304113122455.png" alt="image-20220304113122455" style="zoom:50%;" />

#### (一) 由自动机到正则表达式

##### $\Rarr$递归表达式法

- 路径问题：<img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304113328178.png" alt="image-20220304113328178" style="zoom:50%;" />

- 分类讨论：

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304113511829.png" alt="image-20220304113511829" style="zoom:50%;" />

  > i 到 j 最初是从开始状态到接收状态；
  >
  > 可以这样一直“不经过”，直到递归到 i 直接到 j；

- 构造 DFA

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304113905965.png" alt="image-20220304113905965" style="zoom:50%;" />

- 递归式：

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304114644300.png" alt="image-20220304114644300" style="zoom:50%;" />

- 归纳证明递归式：

  - 归纳基础：$i\ne j$

    <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304114836253.png" alt="image-20220304114836253" style="zoom:50%;" />

  - 归纳基础：$i=j$

    <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304114940908.png" alt="image-20220304114940908" style="zoom:50%;" />

  - 归纳假设与递推

    <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304115053974.png" alt="image-20220304115053974" style="zoom:50%;" />

- 递归表达式应用

  - <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304115225997.png" alt="image-20220304115225997" style="zoom:50%;" />

    <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304115249946.png" alt="image-20220304115249946" style="zoom:50%;" />

    <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304115513107.png" alt="image-20220304115513107" style="zoom:50%;" />

    > 简单的化简规则：
    >
    > <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304115756198.png" alt="image-20220304115756198" style="zoom:50%;" />

    <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304120018475.png" alt="image-20220304120018475" style="zoom:50%;" />

    <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304120116369.png" alt="image-20220304120116369" style="zoom:50%;" />

    <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304120219964.png" alt="image-20220304120219964" style="zoom:50%;" />

    > 其实算$R_{12}^{(2)}$就够了，然后上一次只算求$R_{12}^{(2)}$需要的就够了

    <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304120326197.png" alt="image-20220304120326197" style="zoom:50%;" />

  - <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220304120447501.png" alt="image-20220304120447501" style="zoom:50%;" />

    > 用计算机可以这样算

##### $\Rarr$状态消除法

- 思想/举例解释思想

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220308084429077.png" alt="image-20220308084429077" style="zoom:50%;" />

- 一般情况

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220308084548617.png" alt="image-20220308084548617" style="zoom:50%;" />

  > 重点观察==入边和出边==

> 例题：需要利用**空转移**，增加点和边，不然最后消得什么也不剩了
>
> （这种方式也可以将多个终态合并到一个上）
>
> <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220308084825518.png" alt="image-20220308084825518" style="zoom:50%;" />
>
> <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220308085128195.png" alt="image-20220308085128195" style="zoom:50%;" />
>
> <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220308085302975.png" alt="image-20220308085302975" style="zoom:50%;" />

#### (二) 由正则表达式到自动机

$\Rarr$*定理 4*

<img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220308085409316.png" alt="image-20220308085409316" style="zoom:50%;" />

> 归纳法证明
>
> 归纳基础：
>
> <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220308085617381.png" alt="image-20220308085617381" style="zoom:50%;" />
>
> 归纳递推：
>
> <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220308085748112.png" alt="image-20220308085748112" style="zoom:50%;" />

> 例题：由正则表达式构造$\epsilon-NFA$
>
> 从左向右一点一点构造
>
> <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220308090439179.png" alt="image-20220308090439179" style="zoom:50%;" />

---

### 三、正则表达式的代数定律

---

#### (一) 等价的定义

<img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220308090655939.png" alt="image-20220308090655939" style="zoom:67%;" />

#### (二) 常用代数定律

- 并运算

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220308090738957.png" alt="image-20220308090738957" style="zoom:50%;" />

- 连接运算

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220308090833662.png" alt="image-20220308090833662" style="zoom:50%;" />

- 分配律

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220308090859600.png" alt="image-20220308090859600" style="zoom:67%;" />

- 闭包运算

  <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220308091053901.png" alt="image-20220308091053901" style="zoom:67%;" />

#### (三) 检验

<img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220308091809500.png" alt="image-20220308091809500" style="zoom:50%;" />

> 这种检验方法只适用于带有<u>并、连接和闭包运算</u>的**正则表达式**

> 举例：
>
> <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220308091939329.png" alt="image-20220308091939329" style="zoom:50%;" />
>
> <img src="C:\Users\不怕晒的铃铛\AppData\Roaming\Typora\typora-user-images\image-20220308092334594.png" alt="image-20220308092334594" style="zoom:50%;" />

---

---

## 正则语言的性质

---

---

### 一、正则语言的泵引理

---

#### (一) 正则语言的判断举例

<img src="pics/image-20220315093651726.png" alt="image-20220315093651726" style="zoom:50%;" />

- 例3中的$L_{01}$无法用有穷自动机表示，因为0可以是无穷个

#### (二) 泵引理

<img src="pics/image-20220315093838727.png" alt="image-20220315093838727" style="zoom:67%;" />

> 中间的*y*就可以用来“泵”出新串；
>
> 正整数*N*是正则语言的内在性质；
>
> 被重复的字符串在前*N*个字符中就会出现

> 泵引理是一个**必要条件**，只能用泵引理证明不是正则的

> 证明：
>
> <img src="pics/image-20220315094948706.png" alt="image-20220315094948706" style="zoom:50%;" />

#### (三) 泵引理的应用

> 常用**反证法**，利用*w*的**任意性**进行证明；
>
> 取一个长度大于等于*N*的串，
>
> 满足前两个条件的情况下，泵出一个串，不满足第三个条件

- 证明一个语言不是正则的

  <img src="pics/image-20220315095759948.png" alt="image-20220315095759948" style="zoom:50%;" />

- 证明一个语言不是正则的

  <img src="pics/image-20220315100010666.png" alt="image-20220315100010666" style="zoom:50%;" />

  > 注意，包含了一个非正则语言的集合仍然可能是一个正则语言

- 证明一个语言不是正则的

  <img src="pics/image-20220315100322990.png" alt="image-20220315100322990" style="zoom:50%;" />

  > 这里是将*y*泵没了

- 证明一个较复杂的语言不是正则的

  <img src="pics/image-20220315100905093.png" alt="image-20220315100905093" style="zoom:50%;" />

  > 这里要对*y*进行讨论

> 思考题：
>
> <img src="pics/image-20220315101111949.png" alt="image-20220315101111949" style="zoom:50%;" />
>
> 有限的语言当然都是正则语言，符合泵引理，因为可以小于*N*

> 泵引理只是必要条件：
>
> <img src="pics/image-20220315101426376.png" alt="image-20220315101426376" style="zoom:50%;" />

---

### 二、正则语言的封闭性

---

> 定义：
>
> <img src="pics/image-20220318101002165.png" alt="image-20220318101002165" style="zoom:67%;" />
>
> 证明方法：构造出这个语言的**正则表达式**或**NFA**

#### (一) 并连接闭包补交差

<img src="pics/image-20220318101021459.png" alt="image-20220318101021459" style="zoom:50%;" />

- ##### *并/连接/闭包*

  <img src="pics/image-20220318103139355.png" alt="image-20220318103139355" style="zoom:50%;" />

- ##### *补*

  - 构造：

    <img src="pics/image-20220318103416071.png" alt="image-20220318103416071" style="zoom:50%;" />

  - 证明等价性：

    <img src="pics/image-20220318103530914.png" alt="image-20220318103530914" style="zoom:50%;" />

  > 注：使用这种方法时，DFA不能有**缺失的状态**
  >
  > <img src="pics/image-20220318104222945.png" alt="image-20220318104222945" style="zoom:50%;" />
  >
  > **完整**：任何一种输入和跳转都有对应的状态（<u>死状态</u>也要写出来）
  >
  > DFA求补的方式：接收状态与非接收状态互换

  > **应用**：利用<u>补运算的封闭性</u>，证明语言非正则
  >
  > <img src="pics/image-20220318104505011.png" alt="image-20220318104505011" style="zoom:50%;" />

- *DFA的笛卡尔积定理*

  <img src="pics/image-20220318104839767.png" alt="image-20220318104839767" style="zoom:50%;" />

  > 证明：对$\omega$归纳
  >
  > <img src="pics/image-20220318105144439.png" alt="image-20220318105144439" style="zoom:50%;" />

- ##### *交*

  - 证明1：

    <img src="pics/image-20220318105429540.png" alt="image-20220318105429540" style="zoom:50%;" />

  - 证明2：

    <img src="pics/image-20220318105528635.png" alt="image-20220318105528635" style="zoom:50%;" />

  > 应用举例：
  >
  > <img src="pics/image-20220318105832188.png" alt="image-20220318105832188" style="zoom:50%;" />

  > 非正则语言对<u>交运算</u>是没有封闭性的：
  >
  > <img src="pics/image-20220318110111609.png" alt="image-20220318110111609" style="zoom:50%;" />

- ##### *差*

  <img src="pics/image-20220318110220387.png" alt="image-20220318110220387" style="zoom:50%;" />

#### (二) 反转同态逆同态

- ##### *反转*

  - 反转的定义：

    <img src="pics/image-20220318110317164.png" alt="image-20220318110317164" style="zoom:50%;" />

  - 证明：

    - 目标：

      <img src="pics/image-20220318110556581.png" alt="image-20220318110556581" style="zoom:50%;" />

    - 对<u>正则表达式</u>进行**归纳**：

      <img src="pics/image-20220318110848684.png" alt="image-20220318110848684" style="zoom:50%;" />

      <img src="pics/image-20220318111223160.png" alt="image-20220318111223160" style="zoom:50%;" />

      <img src="pics/image-20220318111530220.png" alt="image-20220318111530220" style="zoom:50%;" />

      <img src="pics/image-20220318111551255.png" alt="image-20220318111551255" style="zoom:50%;" />

      > 分别证明**并**、**连接**、**闭包**

- ##### *同态*

  - 同态的定义：

    <img src="pics/image-20220318111648555.png" alt="image-20220318111648555" style="zoom:50%;" />

    <img src="pics/image-20220318111827491.png" alt="image-20220318111827491" style="zoom:50%;" />

    > 举例理解同态：
    >
    > <img src="pics/image-20220318112137295.png" alt="image-20220318112137295" style="zoom:50%;" />
    >
    > > 注意语言中的 + 代表**并**，而不是字符串的连接，连接是“乘法”，中间没有符号

  - 证明：

    - 目标：

      <img src="pics/image-20220318112344486.png" alt="image-20220318112344486" style="zoom:50%;" />

    - 归纳：

      <img src="pics/image-20220318112638510.png" alt="image-20220318112638510" style="zoom:50%;" />

      <img src="pics/image-20220318113130624.png" alt="image-20220318113130624" style="zoom:50%;" />

- ##### *逆同态*

  - 逆同态的定义：

    <img src="pics/image-20220318113235727.png" alt="image-20220318113235727" style="zoom:50%;" />

    > 逆同态相关证明：
    >
    > <img src="pics/image-20220318114351053.png" alt="image-20220318114351053" style="zoom:50%;" />

  - 证明：

    - 目标：

      <img src="pics/image-20220318113347742.png" alt="image-20220318113347742" style="zoom:50%;" />

      <img src="pics/image-20220318113630097.png" alt="image-20220318113630097" style="zoom:50%;" />

      <img src="pics/image-20220318113749086.png" alt="image-20220318113749086" style="zoom:50%;" />

      <img src="pics/image-20220318113824058.png" alt="image-20220318113824058" style="zoom:50%;" />

> 应用：
>
> <img src="pics/image-20220318114049473.png" alt="image-20220318114049473" style="zoom:50%;" />

---

### 三、正则语言的判定性质

---

> 语言典型的3个问题：
>
> <img src="pics/image-20220318114504238.png" alt="image-20220318114504238" style="zoom:50%;" />

#### (一) 空性、有穷性、无穷性

- 定理：

  <img src="pics/image-20220318114820466.png" alt="image-20220318114820466" style="zoom:50%;" />

- 算法：

  <img src="pics/image-20220318114842025.png" alt="image-20220318114842025" style="zoom:50%;" />

- 定理证明：

  <img src="pics/image-20220318115755926.png" alt="image-20220318115755926" style="zoom:50%;" />

  <img src="pics/image-20220318115826608.png" alt="image-20220318115826608" style="zoom:50%;" />

#### (二) 等价性

<img src="pics/image-20220318115936079.png" alt="image-20220318115936079" style="zoom:50%;" />

----

### 四、自动机的最小化

----

> 最小化算法——**填表算法**

#### (一) 状态的等价性

<img src="pics/image-20220318120052508.png" alt="image-20220318120052508" style="zoom:50%;" />

> <img src="pics/image-20220318120148849.png" alt="image-20220318120148849" style="zoom:50%;" />

#### (二) 填表算法

- 填表算法：

  <img src="pics/image-20220318120248710.png" alt="image-20220318120248710" style="zoom:50%;" />

  > 两个状态经过xxx到达的状态如果是不可区分的，则这两个状态也不可区分；
  >
  > 最初的不可区分是<u>接收状态</u>与<u>非接收状态</u>

- 定理：

  <img src="pics/image-20220318120318238.png" alt="image-20220318120318238" style="zoom:50%;" />

> 应用举例：
>
> <img src="pics/image-20220318120415852.png" alt="image-20220318120415852" style="zoom:50%;" />
>
> <img src="pics/image-20220318120437415.png" alt="image-20220318120437415" style="zoom:50%;" />
>
> <img src="pics/image-20220318120521301.png" alt="image-20220318120521301" style="zoom:50%;" />
>
> <img src="pics/image-20220318120614540.png" alt="image-20220318120614540" style="zoom:50%;" />
>
> <img src="pics/image-20220318120623626.png" alt="image-20220318120623626" style="zoom:50%;" />
>
> <img src="pics/image-20220318120638716.png" alt="image-20220318120638716" style="zoom:50%;" />
>
> <img src="pics/image-20220318120745404.png" alt="image-20220318120745404" style="zoom:50%;" />
>
> <img src="pics/image-20220318120802404.png" alt="image-20220318120802404" style="zoom:50%;" />
>
> <img src="pics/image-20220318121009258.png" alt="image-20220318121009258" style="zoom:50%;" />

#### (三) 等价状态最小化

<img src="pics/image-20220318121138078.png" alt="image-20220318121138078" style="zoom:50%;" />

---

---

## 上下文无关文法

-----

----

### 一、上下文无关文法

---

#### (一) 形式定义

> 自然语言的文法：
>
> <img src="pics/image-20220319085313291.png" alt="image-20220319085313291" style="zoom:50%;" />
>
> <img src="pics/image-20220319085413613.png" alt="image-20220319085413613" style="zoom:50%;" />

##### 1、回文与回文语言

<img src="pics/image-20220319085507858.png" alt="image-20220319085507858" style="zoom:50%;" />

> 使用文法产生回文：
>
> <img src="pics/image-20220319085755706.png" alt="image-20220319085755706" style="zoom:50%;" />

##### 2、上下文无关文法

- 形式定义

  <img src="pics/image-20220319090109583.png" alt="image-20220319090109583" style="zoom:50%;" />

  > T就相当于**字母表**

- A产生式

  <img src="pics/image-20220319090213709.png" alt="image-20220319090213709" style="zoom:50%;" />

  ><img src="pics/image-20220319090250026.png" alt="image-20220319090250026" style="zoom:50%;" />

- 字符使用的一般约定

  <img src="pics/image-20220319090400974.png" alt="image-20220319090400974" style="zoom:50%;" />

> <img src="pics/image-20220319090555343.png" alt="image-20220319090555343" style="zoom:50%;" />

#### (二) 归约和派生

---

##### 1、非形式定义

<img src="pics/image-20220319091006513.png" alt="image-20220319091006513" style="zoom:50%;" />

> 归约举例：
>
> <img src="pics/image-20220319091116239.png" alt="image-20220319091116239" style="zoom:50%;" />

##### 2、形式定义

<img src="pics/image-20220319091216232.png" alt="image-20220319091216232" style="zoom:50%;" />

> <img src="pics/image-20220319091336863.png" alt="image-20220319091336863" style="zoom:50%;" />
>
> <img src="pics/image-20220319091626745.png" alt="image-20220319091626745" style="zoom:50%;" />

> 派生举例：
>
> <img src="pics/image-20220319091757901.png" alt="image-20220319091757901" style="zoom:50%;" />

#### (三) 最左派生和最右派生

<img src="pics/image-20220319091912064.png" alt="image-20220319091912064" style="zoom:50%;" />

> <img src="pics/image-20220319091933181.png" alt="image-20220319091933181" style="zoom:50%;" />

> 举例：
>
> <img src="pics/image-20220319092205141.png" alt="image-20220319092205141" style="zoom:50%;" />

#### (四) 文法的语言

##### 1、形式定义

<img src="pics/image-20220319093737019.png" alt="image-20220319093737019" style="zoom:50%;" />

<img src="pics/image-20220319093801866.png" alt="image-20220319093801866" style="zoom:50%;" />

> <img src="pics/image-20220319093824160.png" alt="image-20220319093824160" style="zoom:50%;" />

##### 2、文法的等价性

- 等价性

  <img src="pics/image-20220319093900060.png" alt="image-20220319093900060" style="zoom:50%;" />

##### 3、句型

<img src="pics/image-20220319094016180.png" alt="image-20220319094016180" style="zoom:50%;" />

> <img src="pics/image-20220319094029690.png" alt="image-20220319094029690" style="zoom:50%;" />
>
> <u>句型</u>中是可以出现**非终结符**的，但<u>句子</u>中不能出现

##### 4、举例

- 语言与文法互推

  <img src="pics/image-20220319094615841.png" alt="image-20220319094615841" style="zoom:50%;" />

  <img src="pics/image-20220319094715411.png" alt="image-20220319094715411" style="zoom:50%;" />

- 语言中含有“<u>不等于</u>”的文法

  > 分成大于和小于两种情况

  <img src="pics/image-20220319095015670.png" alt="image-20220319095015670" style="zoom:50%;" />

  <img src="pics/image-20220319095113014.png" alt="image-20220319095113014" style="zoom:50%;" />

  - L~eq~

    <img src="pics/image-20220319095346330.png" alt="image-20220319095346330" style="zoom:50%;" />

---

### 二、语法分析树

---

> 举例认识：
>
> <img src="pics/image-20220319095855391.png" alt="image-20220319095855391" style="zoom:50%;" />

#### (一) 形式定义

##### 1、形式定义

<img src="pics/image-20220319100005369.png" alt="image-20220319100005369" style="zoom:50%;" />

##### 2、产物与子树

<img src="pics/image-20220319100059099.png" alt="image-20220319100059099" style="zoom:50%;" />

#### (二) 语法树和派生的等价性

定理：

<img src="pics/image-20220319100232501.png" alt="image-20220319100232501" style="zoom:50%;" />

定理证明：

<img src="pics/image-20220319100404095.png" alt="image-20220319100404095" style="zoom:50%;" />

<img src="pics/image-20220319100454295.png" alt="image-20220319100454295" style="zoom:50%;" />

#### (三) 语法分析树唯一确定最左(右)派生

<img src="pics/image-20220319100742984.png" alt="image-20220319100742984" style="zoom:50%;" />

---

### 三、文法和语言的歧义性

---

#### (一) 文法歧义性的消除

##### 1、文法的歧义性

<img src="pics/image-20220319100923662.png" alt="image-20220319100923662" style="zoom:50%;" />

> 举例：
>
> <img src="pics/image-20220319101055707.png" alt="image-20220319101055707" style="zoom:50%;" />

##### 2、文法歧义性的消除

重新设计文法：

<img src="pics/image-20220319101313222.png" alt="image-20220319101313222" style="zoom:50%;" />

#### (二) 语言的固有歧义性

定义：

<img src="pics/image-20220319101338605.png" alt="image-20220319101338605" style="zoom:50%;" />

> <img src="pics/image-20220319101430586.png" alt="image-20220319101430586" style="zoom:50%;" />

---

### 四、文法的化简与范式

---

#### (一) 消除无用符号

<img src="pics/image-20220322083749025.png" alt="image-20220322083749025" style="zoom:50%;" />

定义：

<img src="pics/image-20220322083911377.png" alt="image-20220322083911377" style="zoom:50%;" />

计算“产生的”符号集：

<img src="pics/image-20220322084048873.png" alt="image-20220322084048873" style="zoom:50%;" />

计算“可达的”符号集

<img src="pics/image-20220322084107823.png" alt="image-20220322084107823" style="zoom:50%;" />

> $\alpha$通常是一个**串**，包含多个**符号**

> <img src="pics/image-20220322084229894.png" alt="image-20220322084229894" style="zoom:50%;" />

> 定理：
>
> <img src="pics/image-20220322084301478.png" alt="image-20220322084301478" style="zoom:50%;" />

> 注意：
>
> <img src="pics/image-20220322084336034.png" alt="image-20220322084336034" style="zoom:50%;" />

#### (二) 消除$\epsilon-$产生式

<img src="pics/image-20220322083756569.png" alt="image-20220322083756569" style="zoom:50%;" />

定义：

<img src="pics/image-20220322084819729.png" alt="image-20220322084819729" style="zoom:50%;" />

确定“可空变元”：

<img src="pics/image-20220322084927707.png" alt="image-20220322084927707" style="zoom:50%;" />

替换产生式：

<img src="pics/image-20220322084959637.png" alt="image-20220322084959637" style="zoom:50%;" />

> 要删除$\epsilon$

定理：

<img src="pics/image-20220322085147892.png" alt="image-20220322085147892" style="zoom:50%;" />

> 举例：
>
> <img src="pics/image-20220322085435694.png" alt="image-20220322085435694" style="zoom:50%;" />

#### (三) 消除单元产生式

<img src="pics/image-20220322083802970.png" alt="image-20220322083802970" style="zoom:50%;" />

> 这样的产生式只是增加一个没有必要的推导步骤；
>
> 注意，终结符不算单元产生式

确定“单元对”：

<img src="pics/image-20220322085557612.png" alt="image-20220322085557612" style="zoom:50%;" />

消除单元产生式：

<img src="pics/image-20220322085701449.png" alt="image-20220322085701449" style="zoom:50%;" />

> 注意：是复制，不是剪切

定理：

<img src="pics/image-20220322085727498.png" alt="image-20220322085727498" style="zoom:50%;" />

> 举例：
>
> <img src="pics/image-20220322085911822.png" alt="image-20220322085911822" style="zoom:50%;" />

> :star:化简顺序问题：
>
> <img src="pics/image-20220322085943932.png" alt="image-20220322085943932" style="zoom:50%;" />

#### (四) 乔姆斯基范式

<img src="pics/image-20220322090227973.png" alt="image-20220322090227973" style="zoom:50%;" />

> 派生树的内节点刚好形成二叉树，n-1步产生二叉树，n步派生中间符
>
> <img src="pics/image-20220322090309501.png" alt="image-20220322090309501" style="zoom:50%;" />

CFG遵循CNF格式的方法：

<img src="pics/image-20220322090639707.png" alt="image-20220322090639707" style="zoom:50%;" />

> 举例：
>
> <img src="pics/image-20220322091349153.png" alt="image-20220322091349153" style="zoom:50%;" />
>
> 这里a、b是终结符，不算单元产生式

#### (五) 格雷巴赫范式

<img src="pics/image-20220322093358476.png" alt="image-20220322093358476" style="zoom:50%;" />

> <img src="pics/image-20220322095659652.png" alt="image-20220322095659652" style="zoom:50%;" />
>
> 只要用带有终结符的产生式替换一下即可，但如果<u>变元始终在左侧.</u>..

直接左递归：

<img src="pics/image-20220322100135054.png" alt="image-20220322100135054" style="zoom:50%;" />

> 如果A相关的只有A$\rarr$A$\alpha$，则A就不是产生的了
>
> <img src="pics/image-20220322100341732.png" alt="image-20220322100341732" style="zoom:50%;" />
>
> <img src="pics/image-20220322100413221.png" alt="image-20220322100413221" style="zoom:50%;" />

消除直接左递归：

<img src="pics/image-20220322100604809.png" alt="image-20220322100604809" style="zoom:50%;" />

间接左递归：

<img src="pics/image-20220322100635497.png" alt="image-20220322100635497" style="zoom:50%;" />

> <img src="pics/image-20220322100719177.png" alt="image-20220322100719177" style="zoom:50%;" />

消除间接左递归：

<img src="pics/image-20220322100848631.png" alt="image-20220322100848631" style="zoom:50%;" />

> 举例：
>
> 消除间接
>
> <img src="pics/image-20220322101122106.png" alt="image-20220322101122106" style="zoom:50%;" />
>
> 消除直接
>
> <img src="pics/image-20220322101410653.png" alt="image-20220322101410653" style="zoom:50%;" />
>
> GNF
>
> <img src="pics/image-20220322101733799.png" alt="image-20220322101733799" style="zoom:50%;" />
>
> <img src="pics/image-20220322101817335.png" alt="image-20220322101817335" style="zoom:50%;" />

----

---

## 下推自动机

---

---

### 一、下推自动机

---

#### (一) 形式定义

> 下推自动机模型：
>
> <img src="pics/image-20220325103621587.png" alt="image-20220325103621587" style="zoom:50%;" />

<img src="pics/image-20220325103714691.png" alt="image-20220325103714691" style="zoom:50%;" />

> PDA的动作和状态转移图：
>
> <img src="pics/image-20220325104118074.png" alt="image-20220325104118074" style="zoom:50%;" />

> 举例：
>
> 例1：
>
> <img src="pics/image-20220325104729317.png" alt="image-20220325104729317" style="zoom:50%;" />
>
> <img src="pics/image-20220325104740775.png" alt="image-20220325104740775" style="zoom:50%;" />
>
> 例2：
>
> <img src="pics/image-20220325105333602.png" alt="image-20220325105333602" style="zoom:50%;" />
>
> PDA利用非确定性

#### (二) 瞬时描述和转移符号

<img src="pics/image-20220325110740395.png" alt="image-20220325110740395" style="zoom:50%;" />

<img src="pics/image-20220325110911683.png" alt="image-20220325110911683" style="zoom:50%;" />

> 应用举例：
>
> <img src="pics/image-20220325111433135.png" alt="image-20220325111433135" style="zoom:50%;" />

相关定理：

<img src="pics/image-20220325111539231.png" alt="image-20220325111539231" style="zoom:50%;" />

<img src="pics/image-20220325111644661.png" alt="image-20220325111644661" style="zoom:50%;" />

> 定理24中，栈的部分不能去掉了，因为可能是先弹出来再压进去的

---

### 二、下推自动机接受的语言

---

<img src="pics/image-20220325113615443.png" alt="image-20220325113615443" style="zoom:50%;" />

#### (一) 从终态方式到空栈方式

<img src="pics/image-20220325113722799.png" alt="image-20220325113722799" style="zoom:50%;" />

> 证明：
>
> 构造：
>
> <img src="pics/image-20220325114312866.png" alt="image-20220325114312866" style="zoom:50%;" />
>
> <img src="pics/image-20220325114442569.png" alt="image-20220325114442569" style="zoom:50%;" />
>
> 正确性：
>
> <img src="pics/image-20220325114551371.png" alt="image-20220325114551371" style="zoom:50%;" />
>
> <img src="pics/image-20220325114627551.png" alt="image-20220325114627551" style="zoom:50%;" />

#### (二) 从空栈方式到终态方式

<img src="pics/image-20220329090607981.png" alt="image-20220329090607981" style="zoom:50%;" />

> 证明：
>
> 构造：
>
> <img src="pics/image-20220329090702320.png" alt="image-20220329090702320" style="zoom:50%;" />
>
> <img src="pics/image-20220329091025203.png" alt="image-20220329091025203" style="zoom:50%;" />
>
> 证明正确性：
>
> <img src="pics/image-20220329091545493.png" alt="image-20220329091545493" style="zoom:50%;" />
>
> <img src="pics/image-20220329091608318.png" alt="image-20220329091608318" style="zoom:50%;" />

> 题目举例：
>
> <img src="pics/image-20220329092223569.png" alt="image-20220329092223569" style="zoom:50%;" />
>
> <img src="pics/image-20220329092241074.png" alt="image-20220329092241074" style="zoom:50%;" />
>
> <img src="pics/image-20220329092521531.png" alt="image-20220329092521531" style="zoom:50%;" />
>
> <img src="pics/image-20220329092547522.png" alt="image-20220329092547522" style="zoom:50%;" />

---

### 三、下推自动机与文法的等价性

---

#### (一) 由CFG到PDA

> 举例理解CFG到PDA的方法：
>
> <img src="pics/image-20220329092943588.png" alt="image-20220329092943588" style="zoom:50%;" />
>
> <img src="pics/image-20220329092952916.png" alt="image-20220329092952916" style="zoom:50%;" />
>
> <img src="pics/image-20220329093225334.png" alt="image-20220329093225334" style="zoom:50%;" />
>
> > 思想：利用空转移在栈中产生符合要求的符号串，再和要识别的串匹配
>
> PDA利用栈模拟文法的最左派生
>
> <img src="pics/image-20220329093420523.png" alt="image-20220329093420523" style="zoom:50%;" />
>
> <img src="pics/image-20220329094022488.png" alt="image-20220329094022488" style="zoom:50%;" />
>
> > 其实还是利用空转移产生串，**边产生边消耗**
>
> <img src="pics/image-20220329094615786.png" alt="image-20220329094615786" style="zoom:50%;" />

<img src="pics/image-20220329094757901.png" alt="image-20220329094757901" style="zoom:50%;" />

> 构造：
>
> <img src="pics/image-20220329094828435.png" alt="image-20220329094828435" style="zoom:50%;" />
>
> > :star:变元：空转移+产生逻辑，终结符：消耗掉
>
> 证明：略，不写了，反正我也看不懂

#### (二) 由PDA到CFG

<img src="pics/image-20220401105133847.png" alt="image-20220401105133847" style="zoom:67%;" />

> 构造：
>
> <img src="pics/image-20220401105439278.png" alt="image-20220401105439278" style="zoom:50%;" />
>
> 栈顶符号消耗输入带上的符号串，就相当于变元产生式，
> 但状态不同，消耗不同，所以要连同状态一起定义，
> 且一个栈顶符号为了消耗多个符号串(本来它只能消耗一个终结符)，需要先多压几个符号入栈，再让这几个符号分别产生一个终结符

> 举例：
>
> <img src="pics/image-20220401114341080.png" alt="image-20220401114341080" style="zoom:50%;" />
>
> <img src="pics/image-20220401114514397.png" alt="image-20220401114514397" style="zoom:50%;" />
>
> <img src="pics/image-20220401114524164.png" alt="image-20220401114524164" style="zoom:50%;" />
>
> <img src="pics/image-20220401114637454.png" alt="image-20220401114637454" style="zoom:50%;" />

---

### 四、确定型下推自动机

---

#### (一) 正则语言与DPDA

DPDA定义：

<img src="pics/image-20220401115008225.png" alt="image-20220401115008225" style="zoom:67%;" />

> <img src="pics/image-20220401115019237.png" alt="image-20220401115019237" style="zoom:50%;" />
>
> 对于下推自动机来说，确定型和非确定型识别语言的能力不同

> <img src="pics/image-20220401115105365.png" alt="image-20220401115105365" style="zoom:50%;" />

<img src="pics/image-20220401115146103.png" alt="image-20220401115146103" style="zoom:50%;" />

DPDA与**正则语言**：

<img src="pics/image-20220401115220032.png" alt="image-20220401115220032" style="zoom:50%;" />

> <img src="pics/image-20220401115247781.png" alt="image-20220401115247781" style="zoom:50%;" />

前缀性质：

<img src="pics/image-20220401115327363.png" alt="image-20220401115327363" style="zoom:50%;" />

空栈与终态：

<img src="pics/image-20220401115352153.png" alt="image-20220401115352153" style="zoom:50%;" />

#### (二) DPDA与歧义文法

<img src="pics/image-20220401115425037.png" alt="image-20220401115425037" style="zoom:50%;" />

<img src="pics/image-20220401115520364.png" alt="image-20220401115520364" style="zoom:50%;" />

---

---

## 上下文无关语言的性质

---

---

### 一、上下文无关语言的泵引理

---

#### (一) 上下文无关语言的泵引理

<img src="pics/image-20220408102955098.png" alt="image-20220408102955098" style="zoom:50%;" />

> 必要条件，可以用于证明不是上下文无关语言；
>
> <img src="pics/image-20220408103335968.png" alt="image-20220408103335968" style="zoom:50%;" />

#### (二) 泵引理的应用

反证法证明不是上下文无关语言：

<img src="pics/image-20220408103551114.png" alt="image-20220408103551114" style="zoom:50%;" />

<img src="pics/image-20220408103835498.png" alt="image-20220408103835498" style="zoom:50%;" />

---

### 二、上下文无关语言的封闭性

---

#### (一) 代换的封闭性

代换的定义：

<img src="pics/image-20220408105206710.png" alt="image-20220408105206710" style="zoom:50%;" />

代换的封闭性：

<img src="pics/image-20220408105332358.png" alt="image-20220408105332358" style="zoom:50%;" />

> 证明：
>
> - 构造文法：
>
>   <img src="pics/image-20220408105917215.png" alt="image-20220408105917215" style="zoom:50%;" />
>
>   > 注意$S\in V$
>
> - 证明构造的正确性：
>
>   <img src="pics/image-20220408110351050.png" alt="image-20220408110351050" style="zoom:50%;" />
>
>   <img src="pics/image-20220408110645907.png" alt="image-20220408110645907" style="zoom:50%;" />

:star:文法的构造举例：

<img src="pics/image-20220408111734719.png" alt="image-20220408111734719" style="zoom:50%;" />

- 先写要被代换的语言的文法

  <img src="pics/image-20220408111743968.png" alt="image-20220408111743968" style="zoom:50%;" />

- 再写单个字符代换后所得语言的文法

  <img src="pics/image-20220408112136377.png" alt="image-20220408112136377" style="zoom:50%;" />

  > 这里的开始符可以用被代换的字符当作下标

- 构造代换语言的文法

  > 替换终结符，copy字符代换文法

  <img src="pics/image-20220408112509130.png" alt="image-20220408112509130" style="zoom:50%;" />

#### (二) 并/连接/闭包/同态/逆同态/反转的封闭性

 并/连接/闭包/同态封闭定理：

> 下面的这些证明
>
> - 利用了代换的结论
> - 证明的主要对象是$L_1和L_2$，它们是代换后得到的

<img src="pics/image-20220408112648645.png" alt="image-20220408112648645" style="zoom:50%;" />

<img src="pics/image-20220408113113380.png" alt="image-20220408113113380" style="zoom:50%;" />

反转的封闭性：

<img src="pics/image-20220408113448452.png" alt="image-20220408113448452" style="zoom:50%;" />

> 这只是一种构造的方法，构造正确性的证明省略

逆同态封闭：

<img src="pics/image-20220408114045828.png" alt="image-20220408114045828" style="zoom:50%;" />

> 可以通过构造下推自动机的方式证明：
>
> <img src="pics/image-20220408114319567.png" alt="image-20220408114319567" style="zoom:50%;" />
>
> <img src="pics/image-20220408114551084.png" alt="image-20220408114551084" style="zoom:50%;" />
>
> <img src="pics/image-20220408114635670.png" alt="image-20220408114635670" style="zoom:50%;" />

#### (三) 交和补运算不封闭

<img src="pics/image-20220408114830448.png" alt="image-20220408114830448" style="zoom:50%;" />

<img src="pics/image-20220408114839025.png" alt="image-20220408114839025" style="zoom:50%;" />

> 但是，上下文无关语言与正则语言的交可以得到一个上下文无关语言
>
> <img src="pics/image-20220408115111090.png" alt="image-20220408115111090" style="zoom:50%;" />

#### (四) 封闭性的应用

证明一个语言不是CFL

<img src="pics/image-20220408115835403.png" alt="image-20220408115835403" style="zoom:50%;" />

---

### 三、上下文无关语言的判定性质

---

#### (一) 可判定的CFL问题

<img src="pics/image-20220412083613320.png" alt="image-20220412083613320" style="zoom:50%;" />

#### (二) CYK算法

<img src="pics/image-20220412083902264.png" alt="image-20220412083902264" style="zoom:50%;" />

> 举例：
>
> <img src="pics/image-20220412084229402.png" alt="image-20220412084229402" style="zoom:50%;" />
>
> <img src="pics/image-20220412084347544.png" alt="image-20220412084347544" style="zoom:50%;" />

#### (三) 不可判定的CFL问题

<img src="pics/image-20220412084440417.png" alt="image-20220412084440417" style="zoom:50%;" />

---

### 四、乔姆斯基文法体系

---

<img src="pics/image-20220412084627041.png" alt="image-20220412084627041" style="zoom:67%;" />

---

---

## 图灵机与不可判定性

---

---

### 一、图灵机

---

#### (一) 语言与停机

图灵机的形式定义：

<img src="pics/image-20220412091534534.png" alt="image-20220412091534534" style="zoom:50%;" />

图灵机的动作及状态转移图：

<img src="pics/image-20220412091805446.png" alt="image-20220412091805446" style="zoom:50%;" />

> 举例：
>
> <img src="pics/image-20220412092226112.png" alt="image-20220412092226112" style="zoom:50%;" />
>
> 先找第一个0，再去右边找第一个1，再回来找第二个0，再去右边找第二个1；
>
> 自己模拟几轮，可以发现Y也是需要跳过的
>
> <img src="pics/image-20220412092929072.png" alt="image-20220412092929072" style="zoom:50%;" />

瞬时描述：

- 定义：

  <img src="pics/image-20220412093047982.png" alt="image-20220412093047982" style="zoom:50%;" />

- 转移：

  <img src="pics/image-20220412093337646.png" alt="image-20220412093337646" style="zoom:50%;" />

> 举例：
>
> <img src="pics/image-20220412093415094.png" alt="image-20220412093415094" style="zoom:50%;" />

图灵机的语言：

<img src="pics/image-20220412093706012.png" alt="image-20220412093706012" style="zoom:50%;" />

> 这种情况下如果不停机，不能确定是运行时间不够还是根本无法接收。为了避免这种情况，有了下面这个保证停机的图灵机

<img src="pics/image-20220412093742104.png" alt="image-20220412093742104" style="zoom:50%;" />

> **算法的形式定义**

#### (二) 整数函数计算器

> 图灵机可以用来计算整数函数，也是设计图灵机的最初目的

怎么表示整数？

- 一进制、使用1隔开多个整数

<img src="pics/image-20220412093949506.png" alt="image-20220412093949506" style="zoom:50%;" />

> 举例：
>
> <img src="pics/image-20220412094659794.png" alt="image-20220412094659794" style="zoom:50%;" />
>
> 思想是：先尝试把左边的0标记成B，然后去右边找0，如果没找到直接碰到B了，就说明m$\ge$n，再回去把那个B改成0；如果是m<n，在想标下0为B的时候会发现1，这时候只需将所有的0和1都变成空白
>
> 只要有终止状态就行，可以不写接收状态

#### (三) 图灵机的变形

状态中存储：

<img src="pics/image-20220412094811999.png" alt="image-20220412094811999" style="zoom:50%;" />

> 这是在有穷控制器中存储了一些东西
>
> 与基本的图灵机是等价的

多道：

<img src="pics/image-20220412095040937.png" alt="image-20220412095040937" style="zoom:50%;" />

> 把输入带扩展出多条道；
>
> 还是与基本图灵机等价

> 举例：状态中存储+多道
>
> <img src="pics/image-20220428221455003.png" alt="image-20220428221455003" style="zoom:50%;" />

半无穷带图灵机：

<img src="pics/image-20220428222019309.png" alt="image-20220428222019309" style="zoom:50%;" />

> 可以利用多道技术模拟两端无穷的图灵机

多带图灵机

> 区别：
>
> - 多条带，对应多个读头
> - 读头可以不移动
> - 每个动作要参考所有读头下的符号

<img src="pics/image-20220428222506211.png" alt="image-20220428222506211" style="zoom:50%;" />

> 形式定义较为复杂，这里省略了

> 证明等价性：
>
> <img src="pics/image-20220428222646664.png" alt="image-20220428222646664" style="zoom:67%;" />

#### (四) 图灵机的运行时间

运行时间：

<img src="pics/image-20220428222812144.png" alt="image-20220428222812144" style="zoom:50%;" />

时间复杂度：

<img src="pics/image-20220428222849968.png" alt="image-20220428222849968" style="zoom:50%;" />

单带模拟多带的时间复杂度：

<img src="pics/image-20220428223017122.png" alt="image-20220428223017122" style="zoom:50%;" />

非确定图灵机：

<img src="pics/image-20220428223237338.png" alt="image-20220428223237338" style="zoom:67%;" />

> 等价性证明：
>
> <img src="pics/image-20220428223421535.png" alt="image-20220428223421535" style="zoom:50%;" />
>
> <img src="pics/image-20220428223559709.png" alt="image-20220428223559709" style="zoom:50%;" />
>
> <img src="pics/image-20220428223659521.png" alt="image-20220428223659521" style="zoom:50%;" />

---

### 二、不可判定性

#### (一) 非递归可枚举的语言

可判定问题与不可判定问题的定义：

<img src="pics/image-20220429155645797.png" alt="image-20220429155645797" style="zoom:50%;" />

> 一个重要的判定问题：
>
> <img src="pics/image-20220429155803283.png" alt="image-20220429155803283" style="zoom:50%;" />

将01字符串与整数i进行对应：

<img src="pics/image-20220429155919650.png" alt="image-20220429155919650" style="zoom:50%;" />

对图灵机进行编码：

<img src="pics/image-20220429160105434.png" alt="image-20220429160105434" style="zoom:50%;" />

> 这样就可以将所有01上的图灵机都变成编码

再将图灵机的编码与整数进行对应：

<img src="pics/image-20220429160314191.png" alt="image-20220429160314191" style="zoom:50%;" />

对角化语言：

<img src="pics/image-20220429161120245.png" alt="image-20220429161120245" style="zoom:50%;" />

> <img src="pics/image-20220429161131205.png" alt="image-20220429161131205" style="zoom:50%;" />
>
> > 也就是不存在图灵机去接收它
>
> <img src="pics/image-20220429161444687.png" alt="image-20220429161444687" style="zoom:50%;" />

#### (二) 递归可枚举但非递归的语言

有序对和通用语言：

<img src="pics/image-20220429161603206.png" alt="image-20220429161603206" style="zoom:50%;" />

通用语言性质定理：

<img src="pics/image-20220429162034864.png" alt="image-20220429162034864" style="zoom:50%;" />

<img src="pics/image-20220429162220249.png" alt="image-20220429162220249" style="zoom:50%;" />

通用图灵机：

<img src="pics/image-20220429162331717.png" alt="image-20220429162331717" style="zoom:50%;" />



```
@0226
@1029
@0101
@0105
@0106
@0111
@0115
@0125
@0131
@0211
@0219
@0227
@0230
@0233
@0413
@0415
@0418
@0501
@0505
@0506
@0520
@0526
@0601
@0624
@0729
@0432
@0902
@1019
@1033
@1106
@1128
@1205
@1206
@1222
@1224
@1230
@1233
@1306
@1315
@1322
@1423
@1521
@1603
@1609
@1612
@1615
@1621
@1623
@1625
@1626
```













